<!DOCTYPE html>
<html lang="en">
<head>
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>NativeScript Style Guide</title>

	<meta charset="utf-8">
	<meta name="description" content="An opinionated guide to building mobile apps with NativeScript">
	<meta name="author" content="TJ VanToll">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="css/style.css" rel="stylesheet">
</head>
<body>

<div id="header">
	<a href="#" class="menu header-btn" id="toggle-toc"></a>
	<h1>NativeScript Style Guide</h1>
	<a href="https://github.com/tjvantoll/nativescript-style-guide" class="github header-btn"></a>
</div>

<div id="container">
	<div id="toc">
		<div class="author">by <a href="http://tjvantoll.com">TJ VanToll</a> v 1.0</div>
		<div id="toc-padding"></div>
	</div>
	<div id="book">
		<div class="chapter">
			<h2 id="introduction">Introduction</h2>
<h3 id="what-is-this-">What is this?</h3>
<p>This is an opinionated guide to building native mobile apps with <a href="http://nativescript.org">NativeScript</a>. The advice this guide prescribes is by no means mandatory, however, the very opinionated authors of this guide believe that following these guidelines will help you produce high-quality, maintenance friendly, and performant apps with NativeScript.</p>
<p>Feel free to ignore tips that don&#39;t apply to your projects, or to build upon this advice based on your app&#39;s requirements. If you find an error in this guide, or would like to suggest new guidelines, feel free to <a href="https://github.com/NativeScript/nativescript-style-guide/issues/new">open an issue</a> in <a href="https://github.com/NativeScript/nativescript-style-guide">this guide&#39;s GitHub repo</a>.</p>
<h3 id="who-wrote-this-">Who wrote this?</h3>
<p>The following people have contributed to this guide in some fashion—aka, if you disagree with the advice this guide presents, here are some people you can yell at:</p>
<ul>
<li>TJ VanToll | <a href="http://twitter.com/tjvantoll">@tjvantoll</a></li>
<li>Valio Stoychev | <a href="https://twitter.com/valiostoychev">@valiostoychev</a></li>
<li>Sebastian Witalec | <a href="https://twitter.com/sebawita">@sebawita</a></li>
<li>Clark Sell | <a href="https://twitter.com/csell5">@csell5</a></li>
</ul>
<h3 id="prerequisites">Prerequisites</h3>
<p>This guides assumes you know how to create and run a NativeScript project. If you don&#39;t, start on the <a href="https://github.com/nativescript/nativescript-cli">NativeScript getting started page</a>, and come back here when you&#39;ve got the NativeScript basics down and are looking to create a real app.</p>

		</div>
		<hr>
		<div class="chapter">
			<h2 id="best-practices">Best Practices</h2>
<p>The following are a set of best practices to adhere to when building NativeScript apps.</p>
<h3 id="use-nativescript-s-mvvm-implementation">Use NativeScript&#39;s MVVM implementation</h3>
<p>NativeScript has a robust MVVM implementation that allows you to bind data in JavaScript objects to native UI elements; use it, as it&#39;ll make your code a lot cleaner.</p>
<p>As an example suppose you want to display a list of characters in a ListView control. Here&#39;s an implementation that doesn&#39;t use MVVM:</p>
<pre><code class="lang-markup">&lt;!-- page.xml --&gt;
&lt;Page navigatedTo=&quot;load&quot;&gt;
    &lt;ListView id=&quot;characters&quot; /&gt;
&lt;/Page&gt;
</code></pre>
<pre><code class="lang-javascript">// page.js
var labelModule = require( &quot;ui/label&quot; ),
viewModule = require( &quot;ui/core/view&quot; );

var characters = [ &quot;Sonic&quot;, &quot;Tails&quot;, &quot;Knuckles&quot; ];
exports.load = function( args ) {
var list = viewModule.getViewById( args.object, &quot;characters&quot; );
list.items = characters;
list.on( &quot;itemLoading&quot;, function( args ) {
    if ( !args.view ) {
        args.view = new labelModule.Label();
    }
    args.view.text = characters[ args.index ];
});
</code></pre>
<p>This code shows a list of characters as you&#39;d expect, and it even updates the ListView as you add or remove items from the <code>characters</code> array.</p>
<p>However, there are a few things about this implementation that aren&#39;t so great. First your JavaScript has to know specific things about your view, for instance the <code>&quot;characters&quot;</code> id attribute of the ListView. Second, your JavaScript is responsible for generating the UI for each item in ListView. This violates the <a href="http://en.wikipedia.org/wiki/Separation_of_concerns">separation of concerns</a> design principle, and it&#39;s just ugly—no one wants to type <code>new labelModule.Label()</code>.</p>
<p>Here&#39;s an example that works the same but uses an MVVM implementation:</p>
<pre><code class="lang-markup">&lt;-- page.xml --&gt;
&lt;Page navigatedTo=&quot;load&quot;&gt;
    &lt;ListView items=&quot;{{ characters }}&quot;&gt;
        &lt;ListView.itemTemplate&gt;
            &lt;Label text=&quot;{{ name }}&quot; /&gt;
        &lt;/ListView.itemTemplate&gt;
    &lt;/ListView&gt;
&lt;/Page&gt;
</code></pre>
<pre><code class="lang-javascript">// page.js
var observableModule = require( &quot;data/observable&quot; ),
observableArray = require( &quot;data/observable-array&quot; ),
data = new observableModule.Observable();

data.set( &quot;characters&quot;, new observableArray.ObservableArray([
    { name: &quot;Sonic&quot; }, { name: &quot;Tails&quot; }, { name: &quot;Knuckles&quot; }
]));

exports.load = function( args ) {
    args.object.bindingContext = data;
}
</code></pre>
<p>Here, the JavaScript code now knows nothing about the view&#39;s XML. JavaScript creates the data structure, and the XML code binds to the data using the <code>{{ }}</code> syntax. The MVVM approach also allows you to move the ListView&#39;s item template definition out of JavaScript, and into XML (with the <code>&amp;lt;ListView.itemTemplate&amp;gt;</code> element), which is far more readable.</p>
<h3 id="divide-your-code-into-small-modular-files">Divide your code into small modular files</h3>
<p>Like the MVVM pattern, using small modular files makes your code more readable and maintainable. For example, consider the code from the previous example:</p>
<pre><code class="lang-javascript">// page.js
var observableModule = require( &quot;data/observable&quot; ),
observableArray = require( &quot;data/observable-array&quot; ),
data = new observableModule.Observable();

data.set( &quot;characters&quot;, new observableArray.ObservableArray([
    { name: &quot;Sonic&quot; }, { name: &quot;Tails&quot; }, { name: &quot;Knuckles&quot; }
]));

exports.load = function( args ) {
    args.object.bindingContext = data;
}
</code></pre>
<p>This application&#39;s model data is mixed in with view code. The disadvantage of this approach being, if you want to reuse this character data on other pages in your app, you&#39;re going to need to duplicate code. Let&#39;s look at how you can refactor this code to make it more modular.</p>
<p>A good first step is to move the data itself into a separate file:</p>
<pre><code class="lang-javascript">// characterData.js
var observableModule = require( &quot;data/observable&quot; ),
observableArray = require( &quot;data/observable-array&quot; ),
data = new observableModule.Observable();

data.set( &quot;characters&quot;, new observableArray.ObservableArray([
    { name: &quot;Sonic&quot; }, { name: &quot;Tails&quot; }, { name: &quot;Knuckles&quot; }
]));

module.exports = data;
</code></pre>
<pre><code class="lang-javascript">// page.js
var characterData = require( &quot;./characterData&quot; );

exports.load = function( args ) {
args.object.bindingContext = characterData;
}
</code></pre>
<p>This change not only cleans up your view&#39;s code, but also moves the character data to a more reusable location.</p>
<blockquote>
<p>These examples assume that all files are in the same folder. In a more realistic example you should have a more complex structure to organize your files. Project folder structure is the topic of <a href="#chapter2">Chapter 2</a>.</p>
</blockquote>
<p>In the example above <code>characterData.js</code> acts as a view model, which you can think of as a model object&#39;s whose explicit purpose is to interact with a view. As a further enhancement, you may choose to additionally abstract out your model objects into their own files. Here&#39;s what that looks like for our character example:</p>
<pre><code class="lang-javascript">// Character.js
function Character( name ) {
    this.name = name;
}
module.exports = Character;
</code></pre>
<pre><code class="lang-javascript">// characterData.js
var observableModule = require( &quot;data/observable&quot; ),
observableArray = require( &quot;data/observable-array&quot; ),
Character = require( &quot;./Character&quot; ),
data = new observableModule.Observable();

data.set( &quot;characters&quot;, new observableArray.ObservableArray([
    new Character( &quot;Sonic&quot; ),
    new Character( &quot;Tails&quot; ),
    new Character( &quot;Knuckles&quot; )
]));

module.exports = data;
</code></pre>
<pre><code class="lang-javascript">// page.js
var characterData = require( &quot;./characterData&quot; );

exports.load = function( args ) {
    args.object.bindingContext = characterData;
}
</code></pre>
<p>Here, you use a <code>Character.js</code> file to contain your character model data, which your view model (<code>characterData.js</code>) uses. The advantage again is in the reusability that this approach offers. Any character-specific code can go in <code>Character.js</code>, and any file in your app that needs that functionality can use it without worrying about dependencies.</p>
<h3 id="use-npm-modules-to-solve-problems">Use npm modules to solve problems</h3>
<p><a href="https://www.npmjs.com/">npm</a> has over 100,000 modules. If you have a problem there&#39;s a decent chance that someone has already written a module to solve that problem for you. Not every npm module is going to work with NativeScript, for example modules that depend on the DOM (e.g. Kendo UI), but a whole lot of them will. Let&#39;s look at a few that do.</p>
<p>Suppose you want to sort the array of characters from our previous example into alphabetical order.</p>
<h3 id="embrace-the-platform">Embrace the platform</h3>
<p>???</p>

		</div>
		<hr>
		<div class="chapter">
			<h2 id="folder-structure">Folder structure</h2>
<p>The most contentious religious debates in the software world occur when deciding on naming conventions. Here are the folder and file names that have worked for us.</p>
<h3 id="folder-structure-overview">Folder structure overview</h3>
<p>Here is our recommended folder structure:</p>
<pre><code class="lang-shell">.
├── app
│   ├── app
│   │   ├── app.css
│   │   ├── app.js
│   │   ├── images
│   │   │   └── ...
│   │   ├── lib
│   │   │   └── ...
│   │   ├── shared
│   │   │   ├── css
│   │   │   │   └── ...
│   │   │   ├── models
│   │   │   │   └── ...
│   │   │   ├── utils
│   │   │   │   ├── images.js
│   │   │   │   └── ...
│   │   │   └── ...
│   │   ├── views
│   │   │   └── ...
│   │   └── ...
│   ├── App_Resources
│   │   ├── android
│   │   └── ios
│   └── tns_modules
│       └── ...
└── platforms
    └── ...
</code></pre>
<p>The following sections provide more specific advice based on this structure.</p>
<h3 id="exclude-the-platforms-folder-from-source-control">Exclude the <code>platforms</code> folder from source control</h3>
<p>The <code>platforms</code> folder contains NativeScript-generated code for each platform your app runs on. Because this code is generated it doesn&#39;t belong in source control. If you&#39;re a git user you can exclude this folder by adding <code>platforms</code> to your <code>.gitignore</code>.</p>
<h3 id="exclude-the-node_modules-folder-from-source-control">Exclude the <code>node_modules</code> folder from source control</h3>
<p>The <code>node_modules</code> folder can be generated from your package.json, so it should also should be excluded from source control. If you&#39;re a git user you can exclude the folder by adding <code>node_modules/</code> to your <code>.gitignore</code>.</p>
<h3 id="create-an-images-js-helper-file">Create an <code>images.js</code> helper file</h3>
<p>To avoid duplicating image paths it&#39;s helpful to have a single <code>images.js</code> utility file that contains all image paths that your app needs. As an example, given the folder structure shown above, suppose the <code>images</code> folder contains a <code>logo.png</code> file.</p>
<pre><code class="lang-shell">.
└── app
    └── app
        ├── app.css
        ├── app.js
        └── images
            └── logo.png
</code></pre>
<p>You can then write the following <code>images.js</code> utility that grabs this image&#39;s source:</p>
<pre><code class="lang-javascript">var imageSource = require( &quot;image-source&quot; );

module.exports = {
    logo: imageSource.fromFile( &quot;~/app/images/logo.png&quot; )
};
</code></pre>
<p>With this utility in place you can use <code>images.js</code> in your views:</p>
<pre><code class="lang-javascript">var images = require( &quot;../shared/utils/images&quot; );

exports.load = function( args ) {
    var page = args.object;
    page.bindingContext = { logoSource: images.logo };
}
</code></pre>
<p>And uses it in your XML:</p>
<pre><code class="lang-markup">&lt;Page loaded=&quot;load&quot;&gt;
    &lt;Image source=&quot;{{ logoSource }}&quot; /&gt;
&lt;/Page&gt;
</code></pre>

		</div>
	</div>
</div>

<script src="scripts/built.js"></script>

</body>
</html>