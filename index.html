<!DOCTYPE html>
<html lang="en">
<head>
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>NativeScript Style Guide</title>

	<meta charset="utf-8">
	<meta name="description" content="An opinionated guide to building mobile apps with NativeScript">
	<meta name="author" content="TJ VanToll">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="http://fonts.googleapis.com/css?family=Roboto+Slab:300,400" rel="stylesheet">
	<link href="bower_components/kendo-ui/styles/kendo.common.min.css" rel="stylesheet">
	<link href="bower_components/kendo-ui/styles/kendo.uniform.min.css" rel="stylesheet">
	<link href="bower_components/normalize-css/normalize.css" rel="stylesheet">
	<link href="http://fonts.googleapis.com/css?family=Open+Sans:400,700" rel="stylesheet">
	<link href="bower_components/font-awesome/css/font-awesome.min.css" rel="stylesheet">
	<link href="css/prism.css" rel="stylesheet">
	<link href="css/style.css" rel="stylesheet">
</head>
<body>

<div id="container">
	<div id="header">
		<div>
			<i class="fa fa-bars fa-align-center fa-lg float-left header-btn" id="toggle-toc"></i>
			<a href="https://github.com/tjvantoll/nativescript-style-guide" class="fa fa-github fa-align-center fa-lg float-right header-btn" id="github"></a>
			<h1>NativeScript Style Guide</h1>
		</div>
	</div>

	<div id="content">
		<div>
			<div id="splitter">

				<!-- Table of contents -->
				<div id="toc">
					<div id="author">by <a href="http://tjvantoll.com">TJ VanToll</a> v 1.0</div>
					<div id="toc-padding"></div>
				</div>

				<!-- The contents of the book itself -->
				<div id="book">
					<div id="center-book">

<div class="chapter">
	<h2>Introduction</h2>

	<h3>What is this?</h3>
	<p>This is an opinionated guide to building native mobile apps with <a href="http://nativescript.org">NativeScript</a>. The advice this guide prescribes is by no means mandatory, however, the very opinionated authors of this guide believe that following these guidelines will help you produce high-quality, maintenance friendly, and performant apps with NativeScript.</p>

	<p>Feel free to ignore tips that don't apply to your projects, or to build upon this advice based on your app's requirements. If you find an error in this guide, or would like to suggest new guidelines, feel free to <a href="https://github.com/NativeScript/nativescript-style-guide/issues/new">open an issue</a> in <a href="https://github.com/NativeScript/nativescript-style-guide">this guide's GitHub repo</a>.

	<h3>Who wrote this?</h3>
	<p>The following people have contributed to this guide in some fashion—aka, if you disagree with the advice this guide presents, here are some people you can yell at:</p>
	<ul>
		<li><a href="http://tjvantoll.com">TJ VanToll</a> | <a href="http://twitter.com/tjvantoll">@tjvantoll</a></li>
		<li>Valio Stoychev | <a href="https://twitter.com/valiostoychev">@valiostoychev</a></li>
		<li>Sebastian Witalec | <a href="https://twitter.com/sebawita">@sebawita</a></li>
	</ul>

	<h3>Prerequisites</h3>
	<p>This guides assumes you know how to create and run a NativeScript project. If you don't, start on the <a href="https://github.com/nativescript/nativescript-cli">NativeScript getting started page</a>, and come back here when you've got the NativeScript basics down and are looking to create a real app.</p>
</div>

<div class="chapter">
	<hr>

	<h2>Best Practices</h2>
	<p>The following are a set of best practices to adhere to when building NativeScript apps.</p>

	<h3>Use NativeScript's MVVM implementation</h3>
	<p>NativeScript has a robust MVVM implementation that allows you to bind data in JavaScript objects to native UI elements; use it, as it'll make your code a lot cleaner.</p>

	<p>As an example suppose you want to display a list of characters in a ListView control. Here's an implementation that doesn't use MVVM:</p>

<pre class="line-numbers"><code class="language-markup">&lt;!-- page.xml --&gt;
&lt;Page navigatedTo="load"&gt;
    &lt;ListView id="characters" /&gt;
&lt;/Page&gt;</code></pre>

<pre class="line-numbers"><code class="language-javascript">// page.js
var labelModule = require( "ui/label" ),
    viewModule = require( "ui/core/view" );

var characters = [ "Sonic", "Tails", "Knuckles" ];
exports.load = function( args ) {
    var list = viewModule.getViewById( args.object, "characters" );
    list.items = characters;
    list.on( "itemLoading", function( args ) {
        if ( !args.view ) {
            args.view = new labelModule.Label();
        }
        args.view.text = characters[ args.index ];
    });
}</code></pre>

	<p>This code shows a list of characters as you'd expect, and it even updates the ListView as you add or remove items from the <code>characters</code> array.</p>

	<p>However, there are a few things about this implementation that aren't so great. First your JavaScript has to know specific things about your view, for instance the <code>"characters"</code> id attribute of the ListView. Second, your JavaScript is responsible for generating the UI for each item in ListView. This violates the <a href="http://en.wikipedia.org/wiki/Separation_of_concerns">separation of concerns design principle</a>, and it's just ugly—no one wants to type <code>new labelModule.Label()</code>.</p>

	<p>Here's an example that works the same but uses an MVVM implementation:</p>

<pre class="line-numbers"><code class="language-markup">&lt;-- page.xml --&gt;
&lt;Page navigatedTo="load"&gt;
    &lt;ListView items="{{ characters }}"&gt;
        &lt;ListView.itemTemplate&gt;
            &lt;Label text="{{ name }}" /&gt;
        &lt;/ListView.itemTemplate&gt;
    &lt;/ListView&gt;
&lt;/Page&gt;</code></pre>

<pre class="line-numbers"><code class="language-javascript">// page.js
var observableModule = require( "data/observable" ),
    observableArray = require( "data/observable-array" ),
    data = new observableModule.Observable();

data.set( "characters", new observableArray.ObservableArray([
    { name: "Sonic" }, { name: "Tails" }, { name: "Knuckles" }
]));

exports.load = function( args ) {
    args.object.bindingContext = data;
}</code></pre>

	<p>Here, the JavaScript code now knows nothing about the view's XML. JavaScript creates the data structure, and the XML code binds to the data using the <code>{{ }}</code> syntax. The MVVM approach also allows you to move the ListView's item template definition out of JavaScript, and into XML (with the <code>&lt;ListView.itemTemplate&gt;</code> element), which is far more readable.</p>

	<h3>Divide your code into small modular files</h3>
	<p>Like the MVVM pattern, using small modular files makes your code more readable and maintainable. For example, consider the code from the previous example:</p>

<pre class="line-numbers"><code class="language-javascript">// page.js
var observableModule = require( "data/observable" ),
    observableArray = require( "data/observable-array" ),
    data = new observableModule.Observable();

data.set( "characters", new observableArray.ObservableArray([
    { name: "Sonic" }, { name: "Tails" }, { name: "Knuckles" }
]));

exports.load = function( args ) {
    args.object.bindingContext = data;
}</code></pre>

	<p>This application's model data is mixed in with view code. The disadvantage of this approach being, if you want to reuse this character data on other pages in your app, you're going to need to duplicate code. Let's look at how you can refactor this code to make it more modular.</p>

	<h3>Use npm modules</h3>
	<p>???</p>

	<h3>Embrace the platform</h3>
	<p>???</p>
</div>

<div class="chapter">
	<hr>

	<h2>Folder structure</h2>
	<p>The most contentious religious debates in the software world occur when deciding on naming conventions, so to set the tone of this <i>opinionated</i> guide, folder structure seems like a good place to start.</p>

	<h3>Folder structure overview</h3>
	<p>Here is our recommended folder structure:</p>

<pre><code>.
├── app
│   ├── App_Resources
│   │   ├── android
│   │   └── ios
│   ├── app.css
│   ├── app.js
│   ├── css
│   │   └── ...
│   ├── lib
│   │   └── ...
│   ├── models
│   │   └── ...
│   ├── node_modules
│   │   └── ...
│   ├── package.json
│   ├── tns_modules
│   │   └── ...
│   └── view-models
│   │   └── ...
└── platforms
    ├── android
    └── ios
</code></pre>

	<p>The following sections provide more specific advice based on this structure.</p>

	<h3>Exclude the <code>platforms</code> folder from source control</h3>
	<p>The <code>platforms</code> folder contains NativeScript-generated code for each platform your app runs on. Because this code is generated it doesn't belong in source control. If you're a git user you can exclude this folder by adding <code>platforms/</code> to your <code>.gitignore</code>.</p>

	<h3>Exclude the <code>node_modules</code> folder from source control</h3>
	<p>The <code>node_modules</code> folder can be generated from your package.json, so it should also should be excluded from source control. If you're a git user you can exclude the folder by adding <code>node_modules/</code> to your <code>.gitignore</code>.</p>
</div>

</div> <!-- #center-book -->
</div> <!-- #book -->
</div> <!-- #splitter -->
</div>
</div> <!-- #container -->

<script src="bower_components/jquery/dist/jquery.min.js"></script>
<script src="bower_components/kendo-ui/js/kendo.ui.core.min.js"></script>
<script src="scripts/prism.js"></script>
<script src="scripts/app.js"></script>

</body>
</html>

<!--
<div class="note">
	<div class="notes-title">Notes</div>
	<div class="notes">
		<ul>
			<li>???</li>
		</ul>
	</div>
</div>
-->
